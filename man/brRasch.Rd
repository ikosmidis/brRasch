% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/brRasch.R
\name{brRasch}
\alias{brRasch}
\title{Fitting fixed-effects IRT models using bias-reducing adjusted score functions}
\usage{
brRasch(data, weights, itemsName = "item", subjectsName = "subject",
  dim = 1, br = FALSE, startmaxit = 5, startadjustment = 0.1,
  startmethod = "BFGS", fsmaxit = 1000, fstol = 1e-04, fsridge = 0.001,
  fsinitstepfactor = 1, trace = FALSE, start = NULL, constraints,
  penalty = c("none", "L2", "L2discr"), tuning = 0)
}
\arguments{
\item{data}{a matrix of Binomial counts with the rows corresponding to subjects and columns to items or an object of class \link{compressed}}

\item{weights}{a matrix of weights. If left unspecfied then it is assummed to be a matrix of 1 of the same dimension as data. If \code{data} is an object of class \link{compressed} then the value of \code{weights} will be ignored}

\item{itemsName}{character string specifying the prefix to be used on the column index of data. It is used to specify meanigful names for the model parameters and applied only when colnames(data) is \code{NULL}}

\item{subjectsName}{character string specifying the prefix to be used on the row index of data. It is used to specify meanigful names for the model parameters and applied only when rownames(data) is \code{NULL}}

\item{dim}{non-negative integer. It specifies the dimension of the Rasch model. See Details for more information}

\item{br}{logical scalar. Specified whether fitting whould be done using bias reduction (\code{TRUE}) or maximum likelihood (\code{FALSE})}

\item{startmaxit}{a positive integer. The maximum number of iterations for the calculation of starting values.}

\item{startadjustment}{a positive scalar. The \code{data} is adjusted as \code{startadjustment + data*(1 - 2*startadjustment)} prior to the calculation of starting values. If \code{data} is of class \link{compressed} then \code{data$data*data$weights} is adjusted instead}

\item{startmethod}{the method to be used in the \link{optim} call when calculated starting values. See \link{optim} for details}

\item{fsmaxit}{non-negative interger. Maximum allowed number of (quasi-) Fisher scoring iterations}

\item{fstol}{a positive scalar. If the absolute value of the step-size for all parameters is less than fstol, then the (quasi-) Fisher scoring iteration stops and the maximum likelihood or reduced-bias estimates are deeemed found}

\item{fsridge}{a positive scalar by which the diagonal elements of the expected information matrix are inflated prior to inversion}

\item{fsinitstepfactor}{positive integer. the step-size in the (quasi-) Fisher scoring iterations is initially scaled by \code{2^(-fsinitstepfactor)} and then depending on whether there is an increase in step the scaling factor is sequentially reduced to \code{2^(-fsinitstepfactor - 1)}, \code{2^(-fsinitstepfactor - 2)}, and so on. See Details for more information on the fitting procedure}

\item{trace}{either a logical scalar or a positive integer. If \code{TRUE} then trace information is being printed at each iteration of the (quasi-) Fisher scoring algorithm. If positive integer then information is printed only for the iterations that satisfy \code{iter \%\% trace == 0}}

\item{start}{a vector of starting values for the model parameters. It should be of length \code{I + dim*(S + I)} where \code{S} is \code{nrow(data)} and \code{I} is \code{ncol(data)}}

\item{constraints}{a \link{setConstraints} object. If left unspecified then brRasch will prompt the user in setting the constraints using \code{relimp::pickFrom}}

\item{penalty}{character string specifying the type of reguralization penalty to be used in estimation. See Details for more information}

\item{tuning}{a numeric vector specifying the value for the tuning parameters}
}
\value{
coefficients
}
\description{
'brRasch' is used to fit fixed-effects IRT models by inputting the data in a matrix format and specifying the constraints.
}
\details{

}
\examples{
data(LSAT)

# Use the weighted Bernoulli representation to get the
# coefficients quickly
LSATCompressed <- compress(LSAT)

# Fit a 2PL model to an adjusted version of LSAT data using ML the
# adjustment is p/(2n) which is bias-reducing in logistic regression
# and ensures finiteness of the estimates (see Cordeiro & McCullagh,
# 1991 for details)
adj <- (nrow(LSAT) + 2*ncol(LSAT))/(2*nrow(LSAT)*ncol(LSAT))
lsatCompressed <- within.list(LSATCompressed, data <- adj + data*(1 - 2*adj))


# Set the contrasts so that the first easiness and first
# discrimination parameters are 0 and 1, respectively
constrc <- setConstraintsRasch(data = lsatCompressed$data,
                               dim = 1,
                               which = c(1, 6),
                               values = c(0, 1))

# Fit the 2PL model under those constraints
fitML <- brRasch(lsatCompressed, constraints = constrc, br = FALSE)

\dontrun{
# Plot the IRF from the adjusted data
irf(fitML)
}

# In order to fit a Rasch model to the same data set the constrints so
# that all discrimination parameters are 1
constrc0 <- setConstraintsRasch(data = lsatCompressed$data,
                                dim = 1,
                                which = c(1, 6, 7, 8, 9, 10),
                                values = c(0, 1, 1, 1, 1, 1))

# Fit the 2PL model under those constraints.
fitML0 <- brRasch(lsatCompressed, constraints = constrc0, br = FALSE)

# Crosscheck that the fit is right by comparing with glm
lsatLong <- reshape(lsatCompressed$data, direction = "long",
                    varying = names(lsatCompressed$data),
                    v.names = "y", timevar = "item", idvar = "subject")
lsatLong$w <- reshape(lsatCompressed$weights, direction = "long",
                      varying = names(lsatCompressed$data),
                      v.names = "w", timevar = "item", idvar = "subject")$w
lsatLong <- within(lsatLong, {
                   item <- factor(item)
                   subject <- factor(subject) })
fitML0glm <- glm(y ~ -1 + subject + item, weights = w, family = binomial, data = lsatLong)

# The coefficients are numerically the same
coef(fitML0)
coef(fitML0glm)

\dontrun{
# The IRFs for fitML0 have the same slope
irf(fitML0)
}

# Now get an intermediate fit between Rasch and 2PL by using L2
# penalization on the difference of betas to 1 with tuning = 0.1
fitMLL2 <- brRasch(lsatCompressed, constraints = constrc, br = FALSE,
                   penalty = "L2discr", tuning = 0.1)


\dontrun{
# The IRFs for the L2 penalized fit vary between those of fitML to
# those of fitML0 as tuning grows. Notice the grouping of the
# abilities the closer one moves to fitML0
for (lambda in c(0, 0.1, 1, 10, 100, 1000, 10000)) {
    IRF <- irf(update(fitMLL2, tuning = lambda))
    print(IRF + ggplot2::labs(title = bquote(lambda == .(lambda))))
}
}

\dontrun{
# Now use fitML to get starting values for a reduced-bias fit of the
# original data under the same constraints
# the decompress method will extract the coeeficients
startBR <- decompress(fitML)
# and also rebuild the dataset respecting the order of the abilities in startBR
LSATdecompressed <- decompress(LSATCompressed)
constr <- setConstraintsRasch(data = LSATdecompressed,
                              dim = 1,
                              which = c(1, 6),
                              values = c(0, 1))

# Requires several slow iterations
fitBR1 <- brRasch(LSATdecompressed, constraints = constr, br = TRUE,
                  start = startBR, trace = 1)

# Plot the IRFs
irf(fitBR1)
}

\dontrun{
## Can also use own built-in starting value procedure
fitBR2 <- brRasch(LSAT, constraints = constr, br = TRUE,
                  trace = 1)
}


\dontrun{

    ## Fit two dimensional model
    constr2 <- setConstraintsRasch(data = LSATdecompressed,
                                  dim = 2,
                                  which = c(6, 7, 8, 9, 16, 17),
                                  values = c(1, 1, 1, 1, -0.1, 0.1))
    fitBR2dim <- brRasch(LSATdecompressed, constraints = constr2, br = TRUE, trace = 1, dim = 2, fsinitstepfactor = 1)
    adj <- 0.01
    lsatCompressed <- within.list(LSATCompressed, data <- adj + data*(1 - 2*adj))
    lsatDecompressed <- decompress(lsatCompressed)
    fitBR2dimAdj <- brRasch(lsatDecompressed, constraints = constr2, br = FALSE, trace = 1,
                            dim = 2, fsinitstepfactor = 5, fsridge = 1e-03, startmaxit = 100)
    ## Check this out - it does not converge
}
}

